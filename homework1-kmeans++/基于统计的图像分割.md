# åŸºäºç»Ÿè®¡çš„å›¾åƒåˆ†å‰²

ä¸»è¦æ€è·¯ï¼š

é€šè¿‡å›¾ç‰‡çš„rgbå±æ€§ï¼Œå°†æ‰€æœ‰åƒç´ ç‚¹ä½œä¸ºä¸€å †samplesã€‚æ¯ä¸ªæ ·æœ¬å…·æœ‰ä¸‰ä¸ªå±æ€§ï¼ˆRedï¼ŒGreenï¼ŒBlueï¼‰ï¼Œåœ¨æ­¤åŸºç¡€ä¸Šä¹Ÿå¯ä»¥ä½¿ç”¨åƒç´ ç‚¹åœ¨å›¾ç‰‡ä¸Šçš„ä½ç½®ä¿¡æ¯ä½œä¸ºç‰¹å¾ï¼Œå³ï¼ˆRedï¼ŒGreenï¼ŒBlueï¼Œ$\lambda x$ï¼Œ$\lambda y$ï¼‰ï¼Œé€šè¿‡$\lambda$å‚æ•°å¯ä»¥è°ƒèŠ‚ä½ç½®ä¿¡æ¯åœ¨åˆ†å‰²ä¸­çš„é‡è¦æ€§ã€‚



## Kmeans ++ åˆå§‹åŒ–æ–¹æ³•

å¼•ç”¨ï¼šhttps://www.cnblogs.com/pinard/p/6164214.html

K-Means++çš„å¯¹äºåˆå§‹åŒ–è´¨å¿ƒçš„ä¼˜åŒ–ç­–ç•¥å¦‚ä¸‹ï¼š

1. ä»è¾“å…¥çš„æ•°æ®ç‚¹é›†åˆä¸­éšæœºé€‰æ‹©ä¸€ä¸ªç‚¹ä½œä¸ºç¬¬ä¸€ä¸ªèšç±»ä¸­å¿ƒğœ‡1Î¼1

2. å¯¹äºæ•°æ®é›†ä¸­çš„æ¯ä¸€ä¸ªç‚¹$x_i$ï¼Œè®¡ç®—å®ƒä¸å·²é€‰æ‹©çš„èšç±»ä¸­å¿ƒä¸­æœ€è¿‘èšç±»ä¸­å¿ƒçš„è·ç¦»
   $$
   D(x_i) = arg \min || x_i - \mu_r||_2^2, r = 1, 2, ..., k_{selected}
   $$

3. é€‰æ‹©ä¸€ä¸ªæ–°çš„æ•°æ®ç‚¹ä½œä¸ºæ–°çš„èšç±»ä¸­å¿ƒï¼Œé€‰æ‹©çš„åŸåˆ™æ˜¯ï¼š$D(x_i)$è¾ƒå¤§çš„ç‚¹ï¼Œè¢«é€‰å–ä½œä¸ºèšç±»ä¸­å¿ƒçš„æ¦‚ç‡è¾ƒå¤§

4. é‡å¤2å’Œ3ç›´åˆ°é€‰æ‹©å‡ºkä¸ªèšç±»è´¨å¿ƒ

5. åˆ©ç”¨è¿™kä¸ªè´¨å¿ƒæ¥ä½œä¸ºåˆå§‹åŒ–è´¨å¿ƒå»è¿è¡Œæ ‡å‡†çš„K-Meansç®—æ³•



## Kmeans ++ åˆå§‹åŒ–ä»£ç 

```c++
// kmeans ++
    int init_random_sample_index = rand() % samples_.size();
    centers_[0].feature_ = samples_[init_random_sample_index].feature_;

    // ä¸€æ¬¡è¿­ä»£ç”¨äºé€‰æ‹©ä¸€ä¸ªä¸­å¿ƒ
    for (int now_cluster = 1; now_cluster < centers_.size(); now_cluster ++)
    {
        // è®¡ç®—æ‰€æœ‰sampleåˆ°èšç±»ä¸­å¿ƒæœ€è¿‘è·ç¦»
        for (int now_sample = 0; now_sample < samples_.size(); now_sample ++)
        {
            // åˆå§‹åŒ–è·ç¦»
            samples_[now_sample].distance_ = calc_square_distance(
                centers_[0].feature_, samples_[now_sample].feature_);

            // è®¡ç®—å®ƒä¸å·²é€‰æ‹©çš„èšç±»ä¸­å¿ƒä¸­æœ€è¿‘èšç±»ä¸­å¿ƒçš„è·ç¦»
            for (int check_k = 1; check_k < now_cluster; check_k ++)
            {
                float now_distance = calc_square_distance(
                    centers_[check_k].feature_, samples_[now_sample].feature_);
                if (samples_[now_sample].distance_ > now_distance)
                    samples_[now_sample].distance_ = now_distance;
            }
        }
        
        // ä¾æ®è·ç¦»æ¦‚ç‡é‡‡æ ·
        float array_sum = 0, now_sum = 0, next_sum = samples_[0].distance_;
        for (int i = 0; i < samples_.size(); i ++)
        {
            array_sum += samples_[i].distance_;
        }

        srand((int)time(NULL)); // è®¾ç½®éšæœºæ•°ç§å­

        float now_random_num = rand() / array_sum;

        int sample_result;

        for (int i = 0; i < samples_.size() - 1; i ++)
        {
            if (now_sum < now_random_num && next_sum > now_random_num)
            {
                sample_result = i;
                break;
            }
            now_sum += samples_[i].distance_;
            next_sum += samples_[i + 1].distance_;
        }

        centers_[now_cluster].feature_ = samples_[sample_result].feature_;
    }
}
```



## Kmeanså®ç°ä»£ç ï¼ˆéšæœºåˆå§‹åŒ–ï¼‰

```c++
#include "k_means.h"
#include <algorithm>
#include <vector>

// to generate random number
static std::random_device rd;
static std::mt19937 rng(rd());

/**
 * @brief get_random_index, check_convergence, calc_square_distance are helper
 * functions, you can use it to finish your homework:)
 *
 */

std::set<int> get_random_index(int max_idx, int n);

float check_convergence(const std::vector<Center>& current_centers,
                        const std::vector<Center>& last_centers);

inline float calc_square_distance(const std::array<float, 3>& arr1,
                                  const std::array<float, 3>& arr2);

/**
 * @brief Construct a new Kmeans object
 *
 * @param img : image with 3 channels
 * @param k : wanted number of cluster
 */
Kmeans::Kmeans(cv::Mat img, const int k) {
    centers_.resize(k);
    last_centers_.resize(k);
    samples_.reserve(img.rows * img.cols);

    // save each feature vector into samples
    for (int r = 0; r < img.rows; r++) {
        for (int c = 0; c < img.cols; c++) {
            std::array<float, 3> tmp_feature;
            for (int channel = 0; channel < 3; channel++) {
                tmp_feature[channel] =
                    static_cast<float>(img.at<cv::Vec3b>(r, c)[channel]);
            }
            samples_.emplace_back(tmp_feature, r, c, -1);
        }
    }
}

/**
 * @brief initialize k centers randomly, using set to ensure there are no
 * repeated elements
 *
 */
// TODO Try to implement a better initialization function
void Kmeans::initialize_centers() {
    std::set<int> random_idx =
        get_random_index(samples_.size() - 1, centers_.size());
    int i_center = 0;

    for (auto index : random_idx) {
        centers_[i_center].feature_ = samples_[index].feature_;
        i_center++;
    }
}

/**
 * @brief change the label of each sample to the nearst center
 *
 */
void Kmeans::update_labels() {
    for (Sample& sample : samples_) {
        // TODO update labels of each feature
        float now = 999999999.0;
        for (int i = 0; i < centers_.size(); i ++) {
            float temp = calc_square_distance(sample.feature_, centers_[i].feature_);
            if (temp < now)
            {
                now = temp;
                sample.label_ = i;
            }
        }
    }
}

/**
 * @brief move the centers according to new lables
 *
 */
void Kmeans::update_centers() {
    // backup centers of last iteration
    last_centers_ = centers_;
    // calculate the mean value of feature vectors in each cluster
    // TODO complete update centers functions.
    for (int i = 0; i < centers_.size(); i ++)
    {
        float temp_r = 0, temp_g = 0, temp_b = 0;
        int temp_count = 0;
        for (Sample& sample : samples_)
        {
            if (sample.label_ == i)
            {
                temp_count ++;
                temp_r += sample.feature_[0];
                temp_g += sample.feature_[1];
                temp_b += sample.feature_[2];
            }
        }

        centers_[i].feature_[0] = temp_r / temp_count;
        centers_[i].feature_[1] = temp_g / temp_count;
        centers_[i].feature_[2] = temp_b / temp_count;
    }
}

/**
 * @brief check terminate conditions, namely maximal iteration is reached or it
 * convergents
 *
 * @param current_iter
 * @param max_iteration
 * @param smallest_convergence_radius
 * @return true
 * @return false
 */
bool Kmeans::is_terminate(int current_iter, int max_iteration,
                          float smallest_convergence_radius) const {
    // TODO Write a terminate function.
    // helper funtion: check_convergence(const std::vector<Center>&
    // current_centers, const std::vector<Center>& last_centers)
    if (current_iter >= max_iteration) return true;

    if (check_convergence(centers_, last_centers_) <= smallest_convergence_radius)
        return true;

    return false;
}

std::vector<Sample> Kmeans::get_result_samples() const {
    return samples_;
}
std::vector<Center> Kmeans::get_result_centers() const {
    return centers_;
}
/**
 * @brief Execute k means algorithm
 *                1. initialize k centers randomly
 *                2. assign each feature to the corresponding centers
 *                3. calculate new centers
 *                4. check terminate condition, if it is not fulfilled, return
 *                   to step 2
 * @param max_iteration
 * @param smallest_convergence_radius
 */
void Kmeans::run(int max_iteration, float smallest_convergence_radius) {
    initialize_centers();
    int current_iter = 0;
    while (!is_terminate(current_iter, max_iteration,
                         smallest_convergence_radius)) {
        current_iter++;
        update_labels();
        update_centers();
    }
}

/**
 * @brief Get n random numbers from 1 to parameter max_idx
 *
 * @param max_idx
 * @param n
 * @return std::set<int> A set of random numbers, which has n elements
 */
std::set<int> get_random_index(int max_idx, int n) {
    std::uniform_int_distribution<int> dist(1, max_idx + 1);

    std::set<int> random_idx;
    while (random_idx.size() < n) {
        random_idx.insert(dist(rng) - 1);
    }
    return random_idx;
}
/**
 * @brief Calculate the L2 norm of current centers and last centers
 *
 * @param current_centers current assigned centers with 3 channels
 * @param last_centers  last assigned centers with 3 channels
 * @return float
 */
float check_convergence(const std::vector<Center>& current_centers,
                        const std::vector<Center>& last_centers) {
    float convergence_radius = 0;
    for (int i_center = 0; i_center < current_centers.size(); i_center++) {
        convergence_radius +=
            calc_square_distance(current_centers[i_center].feature_,
                                 last_centers[i_center].feature_);
    }
    return convergence_radius;
}

/**
 * @brief calculate L2 norm of two arrays
 *
 * @param arr1
 * @param arr2
 * @return float
 */
inline float calc_square_distance(const std::array<float, 3>& arr1,
                                  const std::array<float, 3>& arr2) {
    return std::pow((arr1[0] - arr2[0]), 2) + std::pow((arr1[1] - arr2[1]), 2) +
           std::pow((arr1[2] - arr2[2]), 2);
}
```



## ç»“æœï¼ˆéšæœºåˆå§‹åŒ–ï¼‰

![image-20211205004726960](https://s2.loli.net/2021/12/05/MOeE9Qc1rxPboip.png)

k = 5

![image-20211205004759530](https://s2.loli.net/2021/12/05/ojdvDQ7BPJ8nFtY.png)

k = 5

![image-20211205004837037](https://s2.loli.net/2021/12/05/tzkPXug1HhI6rxj.png)

k = 3



## ç»“æœï¼ˆKmeans++ï¼‰

![image-20211205004142082](https://s2.loli.net/2021/12/05/FS7a9ZzsuPfm2QX.png)

k = 3

![image-20211205004233026](https://s2.loli.net/2021/12/05/DGYORQ1oqSrpcga.png)

k = 5

![image-20211205004302392](https://s2.loli.net/2021/12/05/VfDOG3n5Z8KY47E.png)

k = 5





## å…³äºèšç±»ä¸ªæ•°

éšç€èšç±»ä¸ªæ•°çš„å¢åŠ ï¼Œæ€»ä½“æŸå¤±å‡½æ•°å¿…ç„¶ä¸‹é™ã€‚



è¯æ˜ï¼š

å‡å¦‚å½“å‰æœ‰$k$ç±»ï¼Œå½“ç±»å¢åŠ åˆ°$k+1$æ—¶ï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š

1. è‡³å°‘å­˜åœ¨ä¸€ä¸ªç‚¹ï¼Œä¸åœ¨$k$ç±»æ—¶clusterä¸­å¿ƒç‚¹çš„è·ç¦»å¤§äºç¬¬$k+1$ä¸ªä¸­å¿ƒï¼Œæ­¤æ—¶å®ƒè¢«åˆ†åˆ°è¿™ä¸ªç±»ä¸­ï¼Œä½¿å¾—æ•´ä¸ªæŸå¤±å‡½æ•°å˜å°ã€‚
2. ä¸å­˜åœ¨1ä¸­çš„ç‚¹ï¼Œå³æ­¤æ—¶æ–°çš„ä¸€ç±»ä¸­æ²¡æœ‰ä»»ä½•ä¸€ä¸ªç‚¹ï¼Œåœ¨è¿­ä»£ä¸­ï¼Œè¿™ä¸ªæ–°çš„ä¸­å¿ƒä¼šå˜æ›´ï¼Œç›´åˆ°å˜æˆ1çš„æƒ…å†µã€‚



æ€»ä½“æŸå¤±å‡½æ•°ä¸ç±»åˆ«æ•°ç›®ä¸€èˆ¬ä¼šä¸ºä¸‹å›¾çš„å½¢çŠ¶ï¼Œå³åœ¨4ä¹‹å‰ï¼Œsui zå’Œç±»åˆ«çš„å¢å¤šï¼ŒæŸå¤±å‡½æ•°ä¸‹é™å¾ˆå¿«ã€‚ä½†æ˜¯4ä»¥åï¼ŒæŸå¤±å‡½æ•°è™½ç„¶åœ¨ä¸‹é™ï¼Œä½†æ˜¯ä¸‹é™çš„å¾ˆæ…¢ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨4ä½œä¸ºç±»åˆ«æ•°ç›®ã€‚

![image-20211205010034649](https://s2.loli.net/2021/12/05/OrSKRZHsj5o6tYn.png)
